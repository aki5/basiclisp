(let(apply fn args) (fn . args))
(let(list . args) args)
(let(not x) (if x #false #true))
(let(null? x) (equal? x '()))
(let(and . args)
	(if(null? args) #true
		(if(not(car args)) #false
			(apply and (cdr args)))))
(let(or . args)
	(if(null? args) #false
		(if(car args) #true
			(apply or (cdr args)))))
(let(list? lst)
	(if(pair? lst)
		(if(null? lst) #true (list? (cdr lst)))
		(null? lst)))
(let(append head tail)
	(if(null? head) tail
		(cons(car head)(append(cdr head) tail))))
(let(caar ls) (car (car ls)))
(let(cadr ls) (car (cdr ls)))
(let(cddr ls) (cdr (cdr ls)))
(let(cdar ls) (cdr (car ls)))
(let(inject fn key val) (set-cdr! (cdr fn) (cons (cons key val) (cdr (cdr fn)))))
(let(print port . args)
	(let(print-sp needsp)
		(if needsp (print1 port " ") '()))
	(let(print-pair obj needsp)
		(let head (car obj))
		(if(pair? head)
			(if(equal? (car head) function)
				((lambda() (print-sp needsp) (print1 port "(") (print-obj (car (cdr head)) #false) (print1 port ")")))
				((lambda() (print-sp needsp) (print1 port "(") (print-obj head #false) (print1 port ")"))))
			((lambda() (print-sp needsp) (print1 port head))))
		(print-obj (cdr obj) #true))
	(let(print-obj obj needsp)
		(if(pair? obj)
			(print-pair obj needsp)
			(if(null? obj) '()
				((lambda() (print1 port " . ") (print1 port obj))))))
	(print-obj args #false)
	args)
(let(map fn ls)
	(if(null? ls) '()
		(cons(fn(car ls))(map fn(cdr ls)))))
(let(seq a b)
	(if(equal? a b) '()
		(cons a(seq(+ a 1) b))))
(let(reverse ls)
	(let(rev ls r)
		(if(null? ls) r
			(rev(cdr ls)(cons(car ls) r))))
	(rev ls '()))
(let(sort cmp ls)
	(let(merge ls1 ls2)
		(if(null? ls1) ls2
			(if(null? ls2) ls1
				(if(cmp(car ls1)(car ls2))
					(cons(car ls1)(merge(cdr ls1) ls2))
					(cons(car ls2)(merge ls1(cdr ls2)))))))
	(let(pass lls)
		(if(null? lls) lls
			(if(null?(cdr lls)) lls
				(cons(merge(car lls)(car(cdr lls)))
					(pass(cdr(cdr lls)))))))
	(let(sort2 lls)
		(if(null?(cdr lls))(car lls)
			(sort2(pass lls))))
	(let(split lls)
		(if(null? lls) '()
			(cons(cons(car lls) '())(split(cdr lls)))))
	(sort2(split ls)))
(let(fib n)
	(let(fib2 p1 p2 n)
		(if(equal? n 0) '()
			(cons(+ p1 p2)(fib2 p2(+ p1 p2)(- n 1)))))
	(fib2 1 1 n))
(let Y
	(lambda(h)
		((lambda(x)(x x))
			(lambda(g)(h(lambda args((g g) . args)))))))
(let yfac
	(Y
		(lambda(fn)
			(lambda(x)
				(if(less? x 2) 1
					(* x(fn(- x 1))))))))
(let yfib
	(Y
		(lambda(fn)
			(lambda(x)
				(if(less? x 2)
					x
					(+(fn(- x 1))(fn(- x 2))))))))
(let(primegen)
	(let next 2)
	(let primelist '())
	(let (prime? n lst)
		(if(null? lst) #true
			(if(equal? (remainder n (car lst)) 0) #false
				(prime? n (cdr lst)))))
	(let generator (lambda()
		(if(prime? next primelist)
			((lambda(rval)
				(set! primelist (cons next primelist))
				(set! next (+ rval 1))
				rval) next)
			((lambda(rval)
				(set! next (+ rval 1))
				(generator)) next))))
	generator)
(let(getn gen n)
	(if(equal? n 0) '()
		(cons (gen) (getn gen (- n 1)))))
(let(primes n)
	(getn (primegen) n))
(let(factor n)
	(let(fact1 n k)
		(if(equal? n 1) '()
			(if(equal? (remainder n k) 0)
				(cons k (fact1 (/ n k) k))
				(fact1 n (+ k 1)))))
	(fact1 n 2))
(let(flip sign) (if(equal? sign '+) '- '+))
(let(det2x2 sign fact
	a0 a1
	b0 b1)
	(list (list sign (list '* a0 b1 . fact)) (list (flip sign) (list '* b0 a1 . fact))))
(let(det3x3 sign fact
	a0 a1 a2
	b0 b1 b2
	c0 c1 c2)
	(append (det2x2 sign (cons a0 fact) b1 b2 c1 c2)
	(append	(det2x2 (flip sign) (cons a1 fact) b0 b2 c0 c2)
		(det2x2 sign (cons a2 fact) b0 b1 c0 c1))))
(let(make-object val)
	(lambda(method)
		(if(equal? method 'val) val
			'())))
(let(make-vector len)
	(if(less? len 2) 0
		(cons (make-vector (/ len 2)) (make-vector (/ len 2)))))
(let(iabs x) (if(less? x 0) (- x) x))
(let (frandom)
	(let(conv i f)
		(if(less? i 2) f (conv (/ i 2) (if(equal? (remainder i 2) 0) (/ f 2.0) (+ (/ f 2.0) 0.5)))))
	(conv (iabs (random)) 0.0))
(let(pow x y) (if(equal? y 0) 1 (* x (pow x (- y 1)))))
(let(fact x)(if(equal? x 1) 1 (* x (fact (- x 1)))))
(let(trig-step sign xi fi x2 fs res)
	(if(less? fs 30.0)
		(trig-step (- sign) (* xi x2) (* fi fs (+ fs 1.0)) x2 (+ fs 2.0) (+ res (/ (* sign xi) fi)))
		res))
(let(sin x) (trig-step 1.0 x 1.0 (* x x) 2.0 0.0))
(let(cos x) (- 1.0 (trig-step 1.0 (* x x) 2.0 (* x x) 3.0 0.0)))
(let(env-syms env)
	(if(null? env) '()
		(if(null? (car env))
			(env-syms (cdr env))
			(cons (car (car env)) (env-syms (cdr env))))))
(let(env-vals env)
	(if(null? env) '()
		(if(null? (car env))
			(env-vals (cdr env))
			(cons (cdr (car env)) (env-vals (cdr env))))))

(let threads '())

(let(append-thread fn)
	(set! threads (append threads (list fn))))

(let(run-threads)
	(if(null? threads) '()
		((lambda()
			(let fn (car threads))
			(set! threads (cdr threads))
			(fn)))))

(let(thread-yield)
	(let (yield! fn)
		(append-thread fn)
		(run-threads))
	(call/cc yield!))

(let(start-thread fn . args)
	(append-thread (lambda() (apply fn args) (run-threads))))

(let(prloop msg seq)
	(print 1 msg seq "\n")
	(thread-yield)
	(if(less? seq 1) '()
		(prloop msg (- seq 1))))

